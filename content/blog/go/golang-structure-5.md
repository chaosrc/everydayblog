---
title: Go 程序结构（五）
date: 2019-10-11
---

## Go 程序结构（五）



#### 元组(Tuple)赋值

除了前面提到的赋值方式外，Go 还支持另一种赋值方式——元组赋值，允许一次赋值多个变量。

所有右边的表达式在任何变量更新之前执行，当某个变量同时出现在等号两边时非常有用，比如交换两个变量时

```go
x, y = y, x

a[i], a[j] = a[j], a[i]
```


求两个整数的最大公约数
```go
func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a % b
	}
	return a
}
```

计算第 n 个 Fibonacci 数
```go
func fib(n int) int {
	x, y := 0, 1
	
	for i := 2; i <= n ; i++ {
		x, y = y, x + y
	}
	return y
}
```

虽然 Tuple 赋值很好用，但是在使用复杂表达式时应该尽量避免使用 Tuple 赋值，分开成多个语句更容易阅读和理解

当一个函数有多个返回值时，如果使用赋值语句，那么左边的变量数必须与函数返回值的数量相等

```go
// os.Open 函数返回两个值
file, err := os.Open("./a.out")

// map 查找，返回结果，以及是否成功
v, ok := map[key]

// 类型断言
v, ok := v.(T)

// channel 接受
v, ok := <- ch

```

如果不想要某个变量，可以将它赋值为空标识符

```go
// 忽略返回的字节数
_, err := os.Copy(dist, src)

// 忽略返回结果
_, ok := <- ch
```



#### 可赋值性

赋值语句是一种明确的赋值方式，但是程序中还有很多隐含的赋值方式：函数调用隐含了对相应参数的赋值，return 语句隐含了对相应结果变量的赋值，字面量表达式，比如 slice：
```go
metal := []string{"gold", "silver", "bornze"}
```
隐含了对每一个元素的赋值。所有非原始类型比如 map、channel，都有类似的隐含赋值方式

两个变量是否能够使用 == 或 != 与可赋值性相关：在任何比较中，一个运算对象必须能够赋值给第二个运算对象，或者相反









