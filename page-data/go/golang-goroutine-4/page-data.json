{"componentChunkName":"component---src-templates-blog-post-js","path":"/go/golang-goroutine-4/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新","author":"chao"}},"markdownRemark":{"id":"d8f818bb-6ee9-52a8-b29c-a883f93ffa3e","excerpt":"Golang 并发（四）Channelschannels 是 goroutine 之间的连接，是让一个 goroutine 发送值到另一个 goroutine 的一个交流机制。每一个 channel 是一个特定类型值的管道，这个类型被称为 channel 的元素类型。元素类型为 int 的 channel…","html":"<h2>Golang 并发（四）</h2>\n<h4>Channels</h4>\n<p><em>channels</em> 是 goroutine 之间的连接，是让一个 goroutine 发送值到另一个 goroutine 的一个交流机制。每一个 channel 是一个特定类型值的管道，这个类型被称为 channel 的元素类型。元素类型为 int 的 channel 类型写做 <code class=\"language-text\">chan int</code>。</p>\n<p>创建一个 channel 可以使用内置的 make 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// ch 的类型为 chan int</span></code></pre></div>\n<p>和 map 一样，一个 channel 是 make 函数创建的数据结构的引用。复制一个 channel 或者做为一个参数传递给函数时，复制的是引用。和其他引用类型一样，channel 的零值为 nil。</p>\n<p>两个相同类型的 channel 可以使用 == 比较，当两个 channel 引用同一个 channel 数据结构时，比较结果为 true。</p>\n<p>channel 有两个主要的操作: 发送和接收，总体来说就是<em>交流</em>。一个发送语句通过 channel 从一个 goroutine 传输值到另一个执行相应的接收表达式的 goroutine。两个操作都使用 <code class=\"language-text\">&lt;-</code> 操作符。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">ch <span class=\"token operator\">&lt;-</span> x  <span class=\"token comment\">// 发送语句</span>\nx <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>ch <span class=\"token comment\">// 赋值语句中的接收表达式</span>\n<span class=\"token operator\">&lt;-</span>ch     <span class=\"token comment\">// 接收语句；结果被丢弃</span></code></pre></div>\n<p>channel 支持第三个操作：关闭（close），关闭操作设置一个标志表示这个 channel 将不会再有值发送。在一个关闭的 channel 上执行接收操作会接收已经被发送的值，直到没有值剩下，之后任何接收操作都立即完成，并产生 channel 元素类型的零值。</p>\n<p>使用内置的 close 方法关闭 channel</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span></code></pre></div>\n<p>简单的调用 make 方法创建的 channel 叫做 <em>unbuffered channel</em>，但是 make 方法接收可选的第二个参数，一个被称为 channel 容量的整数。如果容量不为 0，make 方法创建一个 <em>buffered channel</em>。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">// unbuffered channel</span>\nch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// unbuffered channel</span>\nch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// buffered channel</span></code></pre></div>\n<h4>Unbuffered Channels</h4>\n<p>一个在 unbufferd channel 上执行发送操作阻塞发送的 goroutine，直到另一个 goroutine 在同一个 channel 执行对应的接收操作，这时值的传输完成，两个 goroutine 可以继续执行。相反，如果一个接收操作先开始，接收的 goroutine 阻塞直到另一个 goroutine 在同一个 channel 执行发送操作。</p>\n<p>通过 unbuffered channel 通信使得发送和接收的 goroutine 同步（synchronize）。所以 unbuffered channel 也被称作同步 channel （synchronous channels）。</p>\n<p>main goroutine 结束时会关闭其他的 goroutine，下面的例子使用同步 channel 使得 main goroutine 等待其他 goroutine 完成再退出</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second <span class=\"token operator\">*</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"done\"</span><span class=\"token punctuation\">)</span>\n\t\tch <span class=\"token operator\">&lt;-</span> <span class=\"token number\">1</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token operator\">&lt;-</span>ch\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"Golang 并发（四）","date":"November 17, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/go/golang-goroutine-4/","previous":{"fields":{"slug":"/go/golang-goroutine-3/"},"frontmatter":{"title":"Golang 并发（三）"}},"next":{"fields":{"slug":"/go/golang-goroutine-5/"},"frontmatter":{"title":"Golang 并发（五）"}}}}}