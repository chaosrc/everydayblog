{"componentChunkName":"component---src-templates-blog-post-js","path":"/go/golang-reflect-1/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新","author":"chao"}},"markdownRemark":{"id":"f108d4fd-1755-5ad4-9b0d-45d758ce83c6","excerpt":"Golang 反射（一）Go…","html":"<h2>Golang 反射（一）</h2>\n<p>Go 提供了一个机制在运行时对变量更新、检查它的值、调用它的方法以及运行固有的操作，而不需要在编译时知道它的类型。这种机制称为反射。反射使得我们可以把类型本身当作第一类值。</p>\n<h4>为什么使用反射</h4>\n<p>有时候我们需要写一个的函数能够一致的处理类型值，但是这些类型不满足一个通用的接口，没有一个已知的呈现，或在设计这个函数时类型还不存在。</p>\n<p>一个熟悉的例子是 fmt.Fprintf 中的格式逻辑，能够很有效的打印任意类型的任意值，甚至是用户定义的类型。下面我们通过现有的知识来尝试实现这个函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Sprint</span><span class=\"token punctuation\">(</span>x <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">type</span>  Stringer <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">switch</span> x <span class=\"token operator\">:=</span> x<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">case</span> Stringer<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">case</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> x\n\t<span class=\"token keyword\">case</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> strconv<span class=\"token punctuation\">.</span><span class=\"token function\">Itoa</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">case</span> <span class=\"token builtin\">float64</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> strconv<span class=\"token punctuation\">.</span><span class=\"token function\">FormatFloat</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">case</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">if</span> x <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"true\"</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>对于 <code class=\"language-text\">[]float</code>、<code class=\"language-text\">map[string][]string</code> 类型我们该如何处理？如果没有一个方式来检查未知值的类型，那么我们很快将会卡住，这时我们需要反射</p>\n<h4>reflect.Type 和 relectj.Value</h4>\n<p>反射通过 reflect 包提供，它定义了两个重要的类型，Type 和 Value。Type 表示一个 Go 类型，它是一个接口有很多方法来识别类型以及检查它们的组件，比如 struct 的字段、函数的参数。reflect.Type 的本质实现是类型描述，和接口值动态类型的实体相同。</p>\n<p>reflect.Typeof 方法接收任何 interface{} 返回一个动态类型 reflect.Type </p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">t <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// int</span></code></pre></div>\n<p>因为 reflect.Typeof 返回接口值的动态类型，因此它总是返回一个具体类型。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> w io<span class=\"token punctuation\">.</span>Writer <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>Stdout\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// *os.File</span></code></pre></div>\n<p>reflect 包中另一个重要的类型是 Value，reflect.Value 可以保存任何类型的值。reflect.ValueOf 方法接收任何类型的 interface{}，返回包含接口动态值的 reflect.Value，同样  reflect.ValueOf 返回的结果也总是具体的 </p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">v <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>          <span class=\"token comment\">//  1</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//  &lt;int Value></span></code></pre></div>\n<p>调用 Value 上的 Type 方法返回类型的 reflect.Type </p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">Type</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// int</span></code></pre></div>\n<p>reflect.ValueOf 的相反操作是 reflect.Value.Interface 方法，它返回 relfect.Value 的具体类型保持的接口</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">f <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\ni <span class=\"token operator\">:=</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">Interface</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// interface{}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2</span></code></pre></div>","frontmatter":{"title":"Golang 反射（一）","date":"December 08, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/go/golang-reflect-1/","previous":{"fields":{"slug":"/go/golang-testing-6/"},"frontmatter":{"title":"Golang 测试（六）"}},"next":{"fields":{"slug":"/go/golang-reflect-2/"},"frontmatter":{"title":"Golang 反射（二）"}}}}}