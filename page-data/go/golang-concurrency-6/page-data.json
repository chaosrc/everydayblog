{"componentChunkName":"component---src-templates-blog-post-js","path":"/go/golang-concurrency-6/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新","author":"chao"}},"markdownRemark":{"id":"a1b27372-8be0-5932-8291-9379c247612d","excerpt":"Golang 共享变量并发（六）Goroutine 和线程可增长的栈每个 OS 线程的栈通常有一个固定大小的内存块（通常是 2MB），用来保存正在调用的函数的本地变量。这个固定大小的栈既太大也太小。2MB 的栈对于小 goroutine…","html":"<h2>Golang 共享变量并发（六）</h2>\n<h4>Goroutine 和线程</h4>\n<h4>可增长的栈</h4>\n<p>每个 OS 线程的栈通常有一个固定大小的内存块（通常是 2MB），用来保存正在调用的函数的本地变量。这个固定大小的栈既太大也太小。2MB 的栈对于小 goroutine 是一个巨大的浪费，而对于最复杂和深度递归的函数并不总是足够大。</p>\n<p>相反，goroutine 以一个小的栈开始（通常是 2KB）。goroutine 的栈像 OS 线程栈一样保存调用函数的本地变量，但是与 OS 线程不同的是，goroutine 的栈不是固定大小的，而是根据需要增加和缩小。goroutine 栈的大小限制可能高达 1GB，尽管只会有很少的 goroutine 使用到。</p>\n<h4>Goroutine 调度</h4>\n<p>OS 线程由 OS 内核调度。每隔几毫秒，硬件定时器中断处理器，一个称为 scheduler 的内核函数被调用，这个函数暂停当前执行的线程并将它的寄存器保存在内存中，然后查看线程列表决定下一个应该执行的线程，并从内存中恢复这个线程的寄存器，然后恢复这个线程的执行。因为线程被内核调度，从一个线程到另一个线程需要完整的上下文切换，然后保存一个用户线程的状态到内存，再恢复另一个线程的状态，最后更新调度器的数据结构。</p>\n<p>Go 运行时包含了自己的调度器，使用一个叫做 m:n 的调度，因为它调度 m 个 goroutine 在 n 个 OS 线程中运行。GO调度器的工作类似于内核的调度，但是它只关心单个 Go 程序的 goroutine。</p>\n<p>不像操作系统的线程调度器，Go 调度器不是通过硬件计时器定期调用，而是隐式的通过特定的 Go 语言结构调度。 比如当一个 goroutine 调用 time.Sleep 或者被 channel 阻塞，调度器将它休眠，运行另一个 goroutine 直到第一个 goroutine 被唤醒为止。因为不需要内核上下文切换，重新调度一个 goroutine 比调度线程更加廉价</p>\n<h4>GOMAXPROCS</h4>\n<p>Go 调度器使用一个叫做 GOMAXPROCS 参数来决定同时有多少个 OS 活动线程来执行 Go 代码。默认值为机器上的 CPU 数量。goroutine 在休眠或阻塞时不需要线程。阻塞在 I/O 、其他系统调用或调用非 Go 函数的 goroutine ，需要 OS 线程，但是不计算在 GOMAXPROCS 中。</p>","frontmatter":{"title":"Golang 共享变量并发（六）","date":"November 30, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/go/golang-concurrency-6/","previous":{"fields":{"slug":"/go/golang-concurrency-4/"},"frontmatter":{"title":"Golang 共享变量并发（四）"}},"next":{"fields":{"slug":"/go/golang-concurrency-5/"},"frontmatter":{"title":"Golang 共享变量并发（五）"}}}}}