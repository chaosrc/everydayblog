{"componentChunkName":"component---src-templates-blog-post-js","path":"/go/golang-concurrency-4/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新","author":"chao"}},"markdownRemark":{"id":"9d415791-5060-5c8a-9bfe-03c6079a6388","excerpt":"Golang 共享变量并发（四）延迟初始化：sync.Once将初始化昂贵的步骤延迟到它需要的时候进行是一个很好的实践。预先加载初始化变量增加了程序启动的延迟，如果程序不总是执行到使用这个变量的部分，那么初始化是不必要的。下面是图片延迟加载上面的模式仅仅使用单个 goroutine 获取变量是可以的，但是 Icon…","html":"<h2>Golang 共享变量并发（四）</h2>\n<h4>延迟初始化：sync.Once</h4>\n<p>将初始化昂贵的步骤延迟到它需要的时候进行是一个很好的实践。预先加载初始化变量增加了程序启动的延迟，如果程序不总是执行到使用这个变量的部分，那么初始化是不必要的。</p>\n<p>下面是图片延迟加载</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> icon <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\ticons <span class=\"token operator\">=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token string\">\"spades.png\"</span><span class=\"token punctuation\">:</span>   <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"spades.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token string\">\"hearts.png\"</span><span class=\"token punctuation\">:</span>   <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hearts.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token string\">\"diamonds.png\"</span><span class=\"token punctuation\">:</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"diamonds.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token string\">\"clubs.png\"</span><span class=\"token punctuation\">:</span>    <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"clubs.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 注意：线程不安全</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token keyword\">if</span> icons <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> icon<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的模式仅仅使用单个 goroutine 获取变量是可以的，但是 Icon 方法并发调用并不安全。</p>\n<p>最简单的正确方式是使用互斥锁同步来保证所有的 goroutine 观察到 loadIcons 的影响</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mu sync<span class=\"token punctuation\">.</span>Mutex\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n\tmu<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> mu<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> icons <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> icon<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然而，强制互斥获取 icons 的代价是两个 goroutine 不能并发的获取变量，即使一旦变量被安全初始化之后也不会再修改。因此建议使用多读锁：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mu sync<span class=\"token punctuation\">.</span>RWMutex\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n\tmu<span class=\"token punctuation\">.</span><span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> icons <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\ticon <span class=\"token operator\">:=</span> icons<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n\t\tmu<span class=\"token punctuation\">.</span><span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> icon\n\t<span class=\"token punctuation\">}</span>\n\tmu<span class=\"token punctuation\">.</span><span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\tmu<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> mu<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> icons <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> icon<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的模式有了更好的并发，但是比较复杂，容易出错。sync 包中对这类一次初始化问题提供了一个特定的方案：sync.Once。Once 由一个互斥锁和布尔变量组成，变量记录初始化是否发生过，互斥锁同时保护布尔变量和客户端数据结构。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> muOnce sync<span class=\"token punctuation\">.</span>Once\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n\tmuOnce<span class=\"token punctuation\">.</span><span class=\"token function\">Do</span><span class=\"token punctuation\">(</span>loadIcons<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> icon<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>sync.Once 中的 Do 方法接收初始化方法做为它的参数。第一次调用时变量为 false ，Do 方法调用 loadIcons 方法并且设置变量为 true；后面的调用什么都不做。</p>","frontmatter":{"title":"Golang 共享变量并发（四）","date":"November 29, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/go/golang-concurrency-4/","previous":{"fields":{"slug":"/go/golang-concurrency-3/"},"frontmatter":{"title":"Golang 共享变量并发（三）"}},"next":null}}}