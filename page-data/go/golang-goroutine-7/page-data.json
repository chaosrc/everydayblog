{"componentChunkName":"component---src-templates-blog-post-js","path":"/go/golang-goroutine-7/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新","author":"chao"}},"markdownRemark":{"id":"79b30b67-4857-54e2-9f17-c8f3cc50274c","excerpt":"Golang 并发（七）缓冲 Channels（Buffered Channles）一个缓冲 channel 有一个元素队列，队列的最大长度由它创建时通过 make 函数的容量参数确定。下面的语句创建一个 string 类型的缓冲 channel。ch 以及它引用的 channel\nMhNFzD.png…","html":"<h2>Golang 并发（七）</h2>\n<h4>缓冲 Channels（Buffered Channles）</h4>\n<p>一个缓冲 channel 有一个元素队列，队列的最大长度由它创建时通过 make 函数的容量参数确定。</p>\n<p>下面的语句创建一个 string 类型的缓冲 channel。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>ch 以及它引用的 channel\n<img src=\"https://s2.ax1x.com/2019/11/20/MhNFzD.png\" alt=\"MhNFzD.png\"></p>\n<p>缓冲 channel 上的一个发送操作将会在它的队列的后面插入一个元素，一个接收操作将会在队列前面移除一个元素。如果 channel 已满，发送操作将会阻塞它所在的 goroutine 直到另一个 goroutine 的接收操作使得 channel 队列有空位。同样，如果 channel 为空，一个接收操作将会阻塞直到另一个 goroutine 发送值。</p>\n<p>上面的缓冲 channel 能够在不阻塞 goroutine 的情况下发送三个值</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">ch <span class=\"token operator\">&lt;-</span> <span class=\"token string\">\"A\"</span>\nch <span class=\"token operator\">&lt;-</span> <span class=\"token string\">\"B\"</span>\nch <span class=\"token operator\">&lt;-</span> <span class=\"token string\">\"B\"</span></code></pre></div>\n<p>这时 channel 已满，如果再向 channel 发送则会阻塞</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/20/MhasaR.png\" alt=\"MhasaR.png\"></p>\n<p>如果我们接收一个值</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;-</span>ch<span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"A\"</span></code></pre></div>\n<p>channel 即不是满的也不是空的，这时发送操作或者接收操作都不会阻塞。通过这种方式， channel 的缓冲解耦了 goroutine 的发送和接收操作。</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/20/MhdgTs.png\" alt=\"MhdgTs.png\"></p>\n<p>调用内置的 cap 方法可以获取 channel 队列的容量</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>len 方法返回channel 队列中当前缓冲的元素的数量</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2</span></code></pre></div>\n<p>下面的 mirrorQuery 方法中 3 个请求并行，将它们的响应发送到缓冲 channel， 然后接收并且仅仅返回第一个响应。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">mirrorQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n\tch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> ch <span class=\"token operator\">&lt;-</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.mirror.com\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> ch <span class=\"token operator\">&lt;-</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b.mirror.com\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> ch <span class=\"token operator\">&lt;-</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c.mirror.com\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;-</span>ch\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span>url <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span><span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果使用非缓冲的 channel ，那么另外两个比较慢的 goroutine 将会发送它们的响应到一个没有 goroutine 接收的 channel 上，这种情况叫做 goroutine 泄露，将会是一个 bug。不像变量的垃圾回收，泄露的 goroutine 不会自动回收，因此确保不需要的 goroutine 正确关闭是非常重要的。</p>","frontmatter":{"title":"Golang 并发（七）","date":"November 20, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/go/golang-goroutine-7/","previous":{"fields":{"slug":"/go/golang-goroutine-6/"},"frontmatter":{"title":"Golang 并发（六）"}},"next":{"fields":{"slug":"/go/golang-goroutine-8/"},"frontmatter":{"title":"Golang 并发（八）"}}}}}