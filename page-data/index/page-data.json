{"componentChunkName":"component---src-pages-index-js","path":"/","webpackCompilationHash":"244ee56c36e36966767c","result":{"data":{"site":{"siteMetadata":{"title":"温故而知新"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Go RPC (五)gRPC 简介gRPC 是 Google 基于 Protobul 开发的跨语言 RPC 框架。gRPC 基于 HTTP/2 协议设计，可基于一个 HTTP/2 连接提供多个服务，对移动设备更加友好。gRPC 技术栈gRPC 入门创建 hello.proto…","fields":{"slug":"/go-rpc/go-rpc-5/"},"frontmatter":{"date":null,"title":"Go RPC (五)","description":null}}},{"node":{"excerpt":"负载均衡现在有 n 个服务节点，需要从这 n…","fields":{"slug":"/go-distribute/go-distribute-3/"},"frontmatter":{"date":"December 30, 2019","title":"负载均衡","description":null}}},{"node":{"excerpt":"分布式锁（一）trylock某些场景下，我们希望一个任务有单一的执行者，后来的 goroutine 在抢锁失败后，需要放弃其流程，这时就可以使用 trylocktrylock 的意思是，尝试加锁，如果成功继续执行后续流程，如果失败也不阻塞流程，而是直接返回加锁的结果。在 Go…","fields":{"slug":"/go-distribute/go-distribute-2/"},"frontmatter":{"date":"December 29, 2019","title":"分布式锁（一）","description":null}}},{"node":{"excerpt":"分布式 ID 生成器有时我们需要生成类似 MySQL 自增 ID 这样不断增大，同时有不会重复的 ID，以支持业务中高并发的场景。Twitter 的 snowflake 算法是这种场景的一个典型解法首先确定一个 64 位的数字，类型位 int6…","fields":{"slug":"/go-distribute/go-distribute-1/"},"frontmatter":{"date":"December 28, 2019","title":"分布式 ID 生成器","description":null}}},{"node":{"excerpt":"Go RCP (八)Token 认证gRPC 为每个 gRPC 方法的调用提供了认证支持，可以基于用户 Token 对不同的方法访问进行权限控制。要实现对每个 gRPC 方法的认证，需要实现 grpc.PerRPCCredentials 接口：GetRequestMetadata…","fields":{"slug":"/go-rpc/go-rpc-8/"},"frontmatter":{"date":"December 27, 2019","title":"Go RCP (八)","description":null}}},{"node":{"excerpt":"Go RCP (七)发布和订阅模式在发布和订阅模式中，由调用者发起的发布行为类似于一个普通的函数调用，而被动的订阅者者类似于 gRPC 中客服端单向流的接收者。下面我们基于 gRPC 的流特性构造一个发布订阅系统。首先定义 Protobuf 接口使用 gRPC…","fields":{"slug":"/go-rpc/go-rpc-7/"},"frontmatter":{"date":"December 26, 2019","title":"Go RCP (七)","description":null}}},{"node":{"excerpt":"Go RPC (六)gRPC 流RPC 是远程函数调用，每次调用的函数参数不能太大，否则会严重影响性能。因此传统的 RPC 方法调用并不适用于数据量大的场景。gRPC 框架针对服务端和客户端提供了流的特性。在 HelloService 中增加一个支持双向流的方法 Channel…","fields":{"slug":"/go-rpc/go-rpc-6/"},"frontmatter":{"date":"December 25, 2019","title":"Go RPC (六)","description":null}}},{"node":{"excerpt":"Go RPC (四)反向 RPC通常的 RPC 是基于 C/S 结构的，RPC 服务端对应网络的服务器，RPC 客户端对应网络客户端。但是在一些特殊场景下，比如内网提供的 RPC 服务无法在外网访问，这时我们可以使用类似反向代理的技术，从内网主动连接到外网 RPC…","fields":{"slug":"/go-rpc/go-rpc-4/"},"frontmatter":{"date":"December 23, 2019","title":"Go RPC (四)","description":null}}},{"node":{"excerpt":"Go RPC (三)基于 RPC 实现 Watch 功能使用 RPC 框架实现一个基本的 Watch 功能，当系统满足某种条件时 Watch 方法返回监控结果。基于 RPC 创建一个简单的基于内存的 KV 数据库，首先定义服务：其中 m 为 map 类型用来储存数据，filter…","fields":{"slug":"/go-rpc/go-rpc-3/"},"frontmatter":{"date":"December 22, 2019","title":"Go RPC (三)","description":null}}},{"node":{"excerpt":"Go rpc (二) ：ProtobufProtobuf 是 Protocal Buffers 的简称，是一个高效、灵活、带有自动序列化机制的数据语言，定位类似于 XML、JSON等描述语言。安装安装 protobuf \nhttps://github.com…","fields":{"slug":"/go-rpc/go-rpc-2/"},"frontmatter":{"date":"December 21, 2019","title":"Go rpc (二)","description":null}}},{"node":{"excerpt":"Go RPC (一)RPC 是远程过程调用的简称，是分布式系统节点之间的一种交流方式。Go 标准库中提供了一个简单的 RPC 实现。RPC 版 “Hello world“创建 HelloService 类型Hello 方法必须满足 Go 中 RPC…","fields":{"slug":"/go-rpc/go-rpc-1/"},"frontmatter":{"date":"December 20, 2019","title":"Go RPC (一)","description":null}}},{"node":{"excerpt":"Go 实战（四）序列化生成 token","fields":{"slug":"/go-example/go-example.4/"},"frontmatter":{"date":"December 19, 2019","title":"Go 实战（四）","description":null}}},{"node":{"excerpt":"Go 实战（三）使用数据库jwt 认证","fields":{"slug":"/go-example/go-exmaple-3/"},"frontmatter":{"date":"December 18, 2019","title":"Go 实战（三）","description":null}}},{"node":{"excerpt":"Golang 实战（一）使用 freshfresh 是一个命令行工具用来在每次保存文件时编译和运行 web 应用安装使用使用 gin 框架gin 是一个用 Golang 编写的 web 框架安装导入代码使用 POST、GET、PUT 等方法路径参数请求参数","fields":{"slug":"/go-example/go-example-1/"},"frontmatter":{"date":"December 16, 2019","title":"Golang 实战（一）","description":null}}},{"node":{"excerpt":"Golang 实战（二）用户注册创建用户模型模型与请求 body 绑定添加表单校验添加路由","fields":{"slug":"/go-example/go-example-2/"},"frontmatter":{"date":"December 16, 2019","title":"Golang 实战（二）","description":null}}},{"node":{"excerpt":"Golang 底层编程（一）Go 语言的设计保证一些安全性能，限制 Go 程序出错的方式。在编译时，类型检查检测大部分对类型的不当操作，比如，使用字符串减去另一个字符串。严格的类型转换规则阻止直接获取内置类型（比如 string，maps，slices，channel…","fields":{"slug":"/go/golang-low-level-1/"},"frontmatter":{"date":"December 14, 2019","title":"Golang 底层编程（一）","description":null}}},{"node":{"excerpt":"Golang 底层编程（二）unsafe.Pointer大部分指针类型写做 ，意思是 T 类型变量的一个指针，unsafe.Pointer 类型是一种特殊种类的指针，能够保存任意变量的地址。当然我们不能对 unsafe.Pointer…","fields":{"slug":"/go/golang-low-level-2/"},"frontmatter":{"date":"December 14, 2019","title":"Golang 底层编程（二）","description":null}}},{"node":{"excerpt":"Golang 反射（六）获取 struct 字段标签在一个 web 服务中，大多数 HTTP 处理方法做的第一件事是提取请求参数到本地变量。定义一个叫 data 的匿名 struct 类型变量，其字段对应 HTTP 请求的参数，struct 的字段标签指定参数名。Unpack…","fields":{"slug":"/go/golang-reflect-6/"},"frontmatter":{"date":"December 13, 2019","title":"Golang 反射（六）","description":null}}},{"node":{"excerpt":"Golang 反射（五）解码 S 表达式词法分析使用 text/scanner 包的 Scanner，将输入流分割成 token 序列。Scanner 的 Scan 方法推进扫描器并且获取下一个 rune 类型的 token。在 read 方法中 Ident…","fields":{"slug":"/go/golang-reflect-5/"},"frontmatter":{"date":"December 12, 2019","title":"Golang 反射（五）","description":null}}},{"node":{"excerpt":"Golang 反射（四）使用 reflect.Value 设置变量Go 表达像 x、x.f1 和 *p 表示一个变量，但是其他的比如 x+1、f(2) 不是变量。变量是一个包含值的可寻址的存储位置，它的值可以通过这个地址更新。reflect.Value…","fields":{"slug":"/go/golang-reflect-4/"},"frontmatter":{"date":"December 11, 2019","title":"Golang 反射（四）","description":null}}},{"node":{"excerpt":"Golang 反射（三）编码 S-表达式（s-express）类似于 JSON、XM，S-表达式也是一种广泛使用的数据格式，是 Lisp 语言的语法。下面我们将实现一个 S-表达式，支持下面几种结构：对于数值和字符串转为对应的类型；对于 struct…","fields":{"slug":"/go/golang-reflect-3/"},"frontmatter":{"date":"December 10, 2019","title":"Golang 反射（三）","description":null}}},{"node":{"excerpt":"Golang 反射（二）递归打印值创建一个 Display 方法，对于任意的复杂结构，打印出值的完整结构，标记每一个元素的路径。Slice 和 Array：使用 Len 方法获取元素的数量，然后通过 Index(i) 方法遍历元素Struct：NumField…","fields":{"slug":"/go/golang-reflect-2/"},"frontmatter":{"date":"December 09, 2019","title":"Golang 反射（二）","description":null}}},{"node":{"excerpt":"Golang 反射（一）Go…","fields":{"slug":"/go/golang-reflect-1/"},"frontmatter":{"date":"December 08, 2019","title":"Golang 反射（一）","description":null}}},{"node":{"excerpt":"Golang 测试（六）Profiling基准测试对于测量特定操作的性能非常有用，但是当我们想要将一个慢的程序变快时，通常不知道从哪儿开始。当我们想要仔细的查看程序的运行速度时，定位关键代码的最好的技术是 profiling。Profiling…","fields":{"slug":"/go/golang-testing-6/"},"frontmatter":{"date":"December 07, 2019","title":"Golang 测试（六）","description":null}}},{"node":{"excerpt":"Golang 测试（五）Benchmark（基准） 函数基准测试是在固定工作负载下测量程序性能的实践。在 Go 中基准测试函数测试函数类似，但是以Benchmark前缀开头，提供一个 *testing.B 参数，同时暴露一个整数 N…","fields":{"slug":"/go/golang-testing-5/"},"frontmatter":{"date":"December 06, 2019","title":"Golang 测试（五）","description":null}}},{"node":{"excerpt":"Golang 测试（四）覆盖率（Coverage）从本质上来讲，测试永远不会完整。没有一个测试数量可以来证明一个包没有 bug…","fields":{"slug":"/go/golang-testing-4/"},"frontmatter":{"date":"December 05, 2019","title":"Golang 测试（四）","description":null}}},{"node":{"excerpt":"Golang 测试（三）外部测试包net/url 包提供 URL 解析，net/http 包提供 web 服务和 HTTP 客户端库，上层的 net/http 依赖下层的 net/url。然而 net/url 中的一个测试需要在 URLs 和 HTTP…","fields":{"slug":"/go/golang-testing-3/"},"frontmatter":{"date":"December 04, 2019","title":"Golang 测试（三）","description":null}}},{"node":{"excerpt":"Golang 测试（二）测试命令go test 工具对于测试库包很有用，但是我们也可以用它来测试命令。一个命名为 main 的包产生一个可执行程序，但是也能做为一个库导入。下面是一个 echo 命令程序：在测试中，我们可以使用多种参数和 flag…","fields":{"slug":"/go/golang-testing-2/"},"frontmatter":{"date":"December 03, 2019","title":"Golang 测试（二）","description":null}}},{"node":{"excerpt":"Golang 测试（一）go test 工具go test 子命令是 Go 包的一个测试驱动。在一个包目录中，以 _test.go 结尾的文件不是 go build 构建的包的一部分，而是 go test 构建的包的一部分。在 *_test.go…","fields":{"slug":"/go/golang-testing-1/"},"frontmatter":{"date":"December 02, 2019","title":"Golang 测试（一）","description":null}}},{"node":{"excerpt":"Golang 共享变量并发（五）示例：并发非阻塞缓存并发非阻塞缓存是一个抽象，它解决一个在实际并发编程中经常出现的问题：函数缓存（memoizing），它缓存函数的结果，这样函数只需要计算一次下面使用 httpGetBody…","fields":{"slug":"/go/golang-concurrency-5/"},"frontmatter":{"date":"November 30, 2019","title":"Golang 共享变量并发（五）","description":null}}},{"node":{"excerpt":"Golang 共享变量并发（六）Goroutine 和线程可增长的栈每个 OS 线程的栈通常有一个固定大小的内存块（通常是 2MB），用来保存正在调用的函数的本地变量。这个固定大小的栈既太大也太小。2MB 的栈对于小 goroutine…","fields":{"slug":"/go/golang-concurrency-6/"},"frontmatter":{"date":"November 30, 2019","title":"Golang 共享变量并发（六）","description":null}}},{"node":{"excerpt":"Golang 共享变量并发（四）延迟初始化：sync.Once…","fields":{"slug":"/go/golang-concurrency-4/"},"frontmatter":{"date":"November 29, 2019","title":"Golang 共享变量并发（四）","description":null}}},{"node":{"excerpt":"Golang 共享变量并发（三）读写互斥锁：sync.RWMutex在一些场景下，我们需要一种特殊的锁允许只读操作彼此平行进行，但是写操作完全独占访问。这种锁称为多读单写锁（multiple readers, single writer lock），在 Go 中通过 sync…","fields":{"slug":"/go/golang-concurrency-3/"},"frontmatter":{"date":"November 28, 2019","title":"Golang 共享变量并发（三）","description":null}}},{"node":{"excerpt":"Golang 共享变量并发(二)互斥锁：sync.Mutex之前我们使用缓冲 channel 做为计数信号来保证不会超过 20 goroutine 同时发送 HTTP 请求。同样的方式，我们可以使用容量为 1 的 channel 来保证每次最多只有一个  goroutine…","fields":{"slug":"/go/golang-concurrency-2/"},"frontmatter":{"date":"November 27, 2019","title":"Golang 共享变量并发(二)","description":null}}},{"node":{"excerpt":"Golang 共享变量并发（一）竞态条件在一个顺序执行的程序中，一个程序只有一个 goroutine，程序的每一步都按照程序逻辑决定的顺序执行，在有两个或多个 goroutine 的程序中，每一个 goroutine…","fields":{"slug":"/go/golang-concurrency-1/"},"frontmatter":{"date":"November 26, 2019","title":"Golang 共享变量并发（一）","description":null}}},{"node":{"excerpt":"Golang 并发（十二）示例：聊天服务器创建一个聊天服务器，让几个用户之间广播文本信息。这个程序有 4 种 goroutine，一个 main goroutine 和 广播 goroutine 实例，每个用户连接有一个 handleConn goroutine…","fields":{"slug":"/go/golang-goroutine-12/"},"frontmatter":{"date":"November 25, 2019","title":"Golang 并发（十二）","description":null}}},{"node":{"excerpt":"Golang 并发（十一）并发目录遍历下面我们创建一个程序，通过命令行指定目录，查询其使用情况，类似于 Linux 中的 du 命令。下面是非并发版本下面是并发版本，使用 sync.WaitGroup 来统计正在运行的 du 方法，当计数为 0 时关闭 sizeChan。","fields":{"slug":"/go/golang-goroutine-11/"},"frontmatter":{"date":"November 24, 2019","title":"Golang 并发（十一）","description":null}}},{"node":{"excerpt":"Golang 并发（十）多路传输和 select下面是一个倒计时程序，time.Tick 函数返回一个 channel，定时发送事件现在添加中断倒计时的功能，在倒计时过程中按下一个按键中断倒计时。首先定义一个 abord channel ，在一个 goroutine…","fields":{"slug":"/go/golang-goroutine-10/"},"frontmatter":{"date":"November 23, 2019","title":"Golang 并发（十）","description":null}}},{"node":{"excerpt":"Golang 并发（九）并发爬虫首先定义一个 crawl 方法，获取某个页面的所有链接主函数类似于广度优先遍历，使用 workList 来记录需要爬取的 URL，每一个 crawl 方法都在一个独立的 goroutine 中执行并且将其爬取的链接发送至 workList…","fields":{"slug":"/go/golang-goroutine-9/"},"frontmatter":{"date":"November 22, 2019","title":"Golang 并发（九）","description":null}}},{"node":{"excerpt":"Golang 并发（八）并行循环下面我们将探讨一些常见的执行并行循环的并发模式。考虑一个全尺寸图片生成缩略图的问题，下面的 ImageFile…","fields":{"slug":"/go/golang-goroutine-8/"},"frontmatter":{"date":"November 21, 2019","title":"Golang 并发（八）","description":null}}},{"node":{"excerpt":"Golang 并发（七）缓冲 Channels（Buffered Channles）一个缓冲 channel 有一个元素队列，队列的最大长度由它创建时通过 make 函数的容量参数确定。下面的语句创建一个 string 类型的缓冲 channel。ch…","fields":{"slug":"/go/golang-goroutine-7/"},"frontmatter":{"date":"November 20, 2019","title":"Golang 并发（七）","description":null}}},{"node":{"excerpt":"Golang 并发（六）单向 Channel 类型随着程序的增长，将大型函数分解成小块是很自然的。上一篇例子中的程序分解为三个函数：squarer 函数位于 pipleline 中间，接收两个参数：输入 channel 和输出 channel…","fields":{"slug":"/go/golang-goroutine-6/"},"frontmatter":{"date":"November 19, 2019","title":"Golang 并发（六）","description":null}}},{"node":{"excerpt":"Golang 并发（五）PiplinesChannel 可以将 goroutine 连接在一起，所以一个 goroutine 的输出可以做为另一个的输入，下面的图展示了三个 goroutine 被两个 channel 连接的情况。Mc8hX8.png第一个 goroutine…","fields":{"slug":"/go/golang-goroutine-5/"},"frontmatter":{"date":"November 18, 2019","title":"Golang 并发（五）","description":null}}},{"node":{"excerpt":"Golang 并发（四）Channelschannels 是 goroutine 之间的连接，是让一个 goroutine 发送值到另一个 goroutine 的一个交流机制。每一个 channel 是一个特定类型值的管道，这个类型被称为 channel…","fields":{"slug":"/go/golang-goroutine-4/"},"frontmatter":{"date":"November 17, 2019","title":"Golang 并发（四）","description":null}}},{"node":{"excerpt":"Golang 并发（三）示例：并发 echo 服务前面的时钟服务中每个连接使用一个 goroutine 。下面的 echo 服务中我们在每个连接中使用多个 goroutine。大多数 echo 服务仅仅是写入读到的内容，只需要对 handleConn…","fields":{"slug":"/go/golang-goroutine-3/"},"frontmatter":{"date":"November 16, 2019","title":"Golang 并发（三）","description":null}}},{"node":{"excerpt":"Golang 并发（二）示例：并发时钟服务网络是使用并发的常见领域，因为服务器通常一次处理多个客户端请求，每个客服端本质上相互独立。下面的例子中使用 net 包来建立网络服务。首先创建一个顺序时钟服务，每秒钟将当前时间发送给客户端Listen 方法创建一个 net…","fields":{"slug":"/go/golang-goroutine-2/"},"frontmatter":{"date":"November 15, 2019","title":"Golang 并发（二）","description":null}}},{"node":{"excerpt":"Golang 并发（一）如今并发编程越来越重要，web 服务器一次处理上千次请求，前端页面渲染 UI 动画同时进行计算和网络请求，甚至传统的数据读取、计算和输出也使用并发来隐藏潜在的 I/O 操作，充分利用现代计算机的多核 CPU。Go…","fields":{"slug":"/go/golang-goroutine-1/"},"frontmatter":{"date":"November 14, 2019","title":"Golang 并发（一）","description":null}}},{"node":{"excerpt":"Golang 接口（八）类型 Switch类型有两种不同的使用方式。第一种，像前面示例的 io.Writer、io.Reader、http.Handler…","fields":{"slug":"/go/golang-interface-8/"},"frontmatter":{"date":"November 13, 2019","title":"Golang 接口（八）","description":null}}},{"node":{"excerpt":"Golang 接口（七）使用类型断言鉴别错误os 包中的文件操作会返回一个错误集。I/O 操作可能会因为任意原因失败，但是通常有三种错误必须不同的处理：文件已经存在（对于创建操作）、文件不存在（对于读取操作）、权限不够。os…","fields":{"slug":"/go/golang-interface-7/"},"frontmatter":{"date":"November 12, 2019","title":"Golang 接口（七）","description":null}}},{"node":{"excerpt":"Golang 接口（六）类型断言类型断言是对接口值的操作，它的语法为  其中 x 是接口类型表达式，T 为断言类型。类型断言检查操作对象的动态类型是否与断言类型匹配。有两种情况的断言，第一，如果断言类型是一个具体类型，那么断言操作检查 x 的动态类型是否与 T…","fields":{"slug":"/go/golang-interface-6/"},"frontmatter":{"date":"November 11, 2019","title":"Golang 接口（六）","description":null}}},{"node":{"excerpt":"Golang 接口（五）http.Handler 接口net/http 包可以用来实现 web 客户端和服务端，服务端的基本接口为 http.Handler:ListenAndServe 方法需要一个服务器地址(比如“localhost:8000”)和一个 Handler…","fields":{"slug":"/go/golang-interface-5/"},"frontmatter":{"date":"November 10, 2019","title":"Golang 接口（五）","description":null}}},{"node":{"excerpt":"Golang 接口（四）排序接口 sort.Interface和字符串格式化一样，排序在很多编程语言中也是一个非常频繁的操作。Go 中的 sort 包提供了根据排序函数对任何序列进行就地(in-place…","fields":{"slug":"/go/golang-interface-4/"},"frontmatter":{"date":"November 09, 2019","title":"Golang 接口（四）","description":null}}},{"node":{"excerpt":"Golang 接口（三）接口值从概念上讲，一个接口类型的值由两个部分组成：具体类型和此类型的值，它们被称为接口的动态类型和动态值。对于像 Go 这样的静态类型的语言，类型是编译时概念，因此类型不是一个值。在 Go…","fields":{"slug":"/go/golang-interface-3/"},"frontmatter":{"date":"November 08, 2019","title":"Golang 接口（三）","description":null}}},{"node":{"excerpt":"Golang 接口（二）接口类型接口类型指定一组方法，具体的类型必须拥这些方法才能被视为该接口的实例。io.Writer 类型是使用最广泛的接口之一，它提供了所有能够写入字节的类型的抽象，包括文件、内存缓冲、网络连接、压缩器等。一个 Reader…","fields":{"slug":"/go/golang-interface-2/"},"frontmatter":{"date":"November 07, 2019","title":"Golang 接口（二）","description":null}}},{"node":{"excerpt":"Golang 接口（一）接口类型表达对其他类型的广义或者抽象行为。通过抽象，接口让我们编写更加灵活、可适配的函数，因为他们不和具体的实现细节绑定很多面向对象的语言都有接口的概念，但是 Go…","fields":{"slug":"/go/golang-interface-1/"},"frontmatter":{"date":"November 06, 2019","title":"Golang 接口（一）","description":null}}},{"node":{"excerpt":"Golang 方法（四）Struct 嵌入的组合类型考虑下面的 ColoredPoint 类型在 ColoredPoint struct 中我们嵌入一个 Point 来提供 X、Y 值，而不是去定义 X、Y、Color…","fields":{"slug":"/go/golang-method-4/"},"frontmatter":{"date":"November 05, 2019","title":"Golang 方法（四）","description":null}}},{"node":{"excerpt":"Golang 方法（三）方法值和表达式通常我们在同一个表达式中选择并调用方法，比如 ，但是这两个操作是可以分开的。选择器  生成了一个方法值，这个函数将方法（p.Distance）绑定到特定的 receiver 值 p 。然后可以调用这个函数而不需要 receiver…","fields":{"slug":"/go/golang-method-3/"},"frontmatter":{"date":"November 04, 2019","title":"Golang 方法（三）","description":null}}},{"node":{"excerpt":"Golang 方法（二）指针 receiver 方法调用一个函数会拷贝每一个参数值，如果一个函数需要更新一个变量，或者如果参数很大我们需要避免拷贝它，这时我们需要通过变量的指针来传递地址。对于方法也是一样如果需要更新 receiver 变量，应该附加类型的指针，比如 *Point…","fields":{"slug":"/go/golang-method-2/"},"frontmatter":{"date":"November 03, 2019","title":"Golang 方法（二）","description":null}}},{"node":{"excerpt":"Golang 方法（一）自20世纪90年代初以来，面向对象编程一直是工业和教育领域的主流编程范式，几乎所有广泛使用的编程语言都对它进行了支持，Go…","fields":{"slug":"/go/golang-method-1/"},"frontmatter":{"date":"November 02, 2019","title":"Golang 方法（一）","description":null}}},{"node":{"excerpt":"Golang 函数（五）Panic在 Go 的类型系统中很多错误在编译时就能捕获，但是其他的，比如数组越界或者 nil 指针引用，需要运行时检查。当 Go 运行时检测到错误，它将发生 painc。在一个典型的 painc 中，正常的执行停止，所有在当前 goroutine…","fields":{"slug":"/go/golang-function-5/"},"frontmatter":{"date":"November 01, 2019","title":"Golang 函数（五）","description":null}}},{"node":{"excerpt":"Golang 函数（四）可变参数函数一个可变参数函数可以使用不同数量的参数调用函数。对最后一个参数类型使用省略号 ”…” 来声明可变参数。调用者会隐式的创建一个数组，拷贝参数至数组，将整个数组的slice 传人函数。如果参数已经是 slice 可以在参数后面加省略号传人defer…","fields":{"slug":"/go/golang-function-4/"},"frontmatter":{"date":"October 31, 2019","title":"Golang 函数（四）","description":null}}},{"node":{"excerpt":"Golang 函数（三）函数值函数在 Go 中是第一类（first-class）值，和其他值一样，函数有类型，可以赋值给变量、作为参数传入函数或者从函数中返回。函数值可以像任何其他函数一样调用：函数类型的零值为 nil。调用 nil 的函数会导致 panic函数值可以和 nil…","fields":{"slug":"/go/golang-function-3/"},"frontmatter":{"date":"October 30, 2019","title":"Golang 函数（三）","description":null}}},{"node":{"excerpt":"Golang 函数（二）Errors错误是包 API 或者应用程序用户界面的重要组成部分，失败只是可预期的行为之一，这就是 Go 处理错误的方式对于一个方法如果失败是一个可预期的行为则返回一个额外的结果，通常是最后一个。比如查找一个 key，key 值可能不存在通常，特别是 I…","fields":{"slug":"/go/golang-function-2/"},"frontmatter":{"date":"October 29, 2019","title":"Golang 函数（二）","description":null}}},{"node":{"excerpt":"Golang 函数（一）函数声明一个函数的声明包括函数名称、参数列表、可选的返回列表和函数主体：参数列表指定了函数参数的名称和类型，返回列表指定了函数返回值的类型。下面定义了一个 hypot…","fields":{"slug":"/go/golang-function-1/"},"frontmatter":{"date":"October 28, 2019","title":"Golang 函数（一）","description":null}}},{"node":{"excerpt":"Golang 复合类型（七）JSONJSON 是传输结构化数据使用最广泛的形式。Go 标准库中的 encoding/json、encoding/xml、encoding/asn1等包，对 josn、xml、asn1 等格式的编码和解码都有非常好的支持，并且提供了相似的 APIs…","fields":{"slug":"/go/golang-composite-type-7/"},"frontmatter":{"date":"October 27, 2019","title":"Golang 复合类型（七）","description":null}}},{"node":{"excerpt":"Golang 复合类型（六）struct 字面量一个 struct…","fields":{"slug":"/go/golang-composite-type-6/"},"frontmatter":{"date":"October 26, 2019","title":"Golang 复合类型（六）","description":null}}},{"node":{"excerpt":"Golang 复合类型（五）Structs一个 struct 由零个或多个任意类型的命名的字段组成下面声明一个 Employee 类型的 struct，以及一个 Employee 实例 foofoo 中的字段通过点符号来获取比如 ，因为 foo…","fields":{"slug":"/go/golang-composite-type-5/"},"frontmatter":{"date":"October 25, 2019","title":"Golang 复合类型（五）","description":null}}},{"node":{"excerpt":"Golang 复合类型（四）Maps哈希表是最灵活和通用的数据结构之一。它是一个无序的 key/value 键值对集合，所有的 key 都是唯一的，对应的 value 可以通过 key 检索、更新、移除。在 Go 中，一个 map 指向一个哈希表，map 的类型写作 mapKV…","fields":{"slug":"/go/golang-composite-type-4/"},"frontmatter":{"date":"October 24, 2019","title":"Golang 复合类型（四）","description":null}}},{"node":{"excerpt":"Golang 复合类型（三）append 函数内置的 append 函数将元素添加到 slice 上理解 slice 对于 append 函数十分重要。下面是 appendInt 函数用来追加 int 类型的 slice每次 appendInt…","fields":{"slug":"/go/golang-composite-type-3/"},"frontmatter":{"date":"October 23, 2019","title":"Golang 复合类型（三）","description":null}}},{"node":{"excerpt":"Golang 复合类型（二）SliceSlice 是每个元素具有相同类型的可变长度序列，slice 写做 []T，其中 T 为元素类型，看上去和没有长度的数组很像slice 由三部分组成：指针、长度和容量。指针指向 slice 能够接触到的第一个数组元素。长度是 slice…","fields":{"slug":"/go/golang-composite-type-2/"},"frontmatter":{"date":"October 22, 2019","title":"Golang 复合类型（二）","description":null}}},{"node":{"excerpt":"Golang 复合类型（一）Arrays (数组)数组是由零个或多个特定类型的元素组成的固定长度序列。因为数组是固定长度的，所以在 Go 中很少直接使用，而是使用更加灵活的 slice（切片），但是理解切片之前必须先理解数组数组中通过下标获取单个元素，内置的 len…","fields":{"slug":"/go/golang-composite-type-1/"},"frontmatter":{"date":"October 21, 2019","title":"Golang 复合类型（一）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（六）Strings 和 Numbers 之间转换整数转换为字符串有两种方式: fmt.Sprintf 和 strconv.ItoaFormatInt…","fields":{"slug":"/go/golang-basic-type-6/"},"frontmatter":{"date":"October 20, 2019","title":"Golang 基础数据类型（六）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（五）Strings 和 Byte 操作操作字符串最重要的四个包：bytes、strings、strconv 和 unicode。strings 包提供了很多对字符串比如搜索、替换、比较、分隔的方法bytes…","fields":{"slug":"/go/golang-basic-type-5/"},"frontmatter":{"date":"October 19, 2019","title":"Golang 基础数据类型（五）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（四）UTF-8UTF-8 是一个可变长度的 Unicode 编码，它使用 1 到4 个字节来呈现每一个符号（rune），只有 ASCII 字符是 1 个字节，其他通常是 2 到 3 个字节。第一个字节的高阶位指示后面有多少个字节，高阶位为 0 表示…","fields":{"slug":"/go/golang-basic-type-4/"},"frontmatter":{"date":"October 18, 2019","title":"Golang 基础数据类型（四）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（三）Strings字符串是不可变的字节数列。Strings 可以包含任意的数据，包括值为 0 的字节，但是通常是包含人类可读的文本。文本字符串被解析为 UTF-8 编码的 Unicode 代码点（runes）内置的 len…","fields":{"slug":"/go/golang-basic-type-3/"},"frontmatter":{"date":"October 17, 2019","title":"Golang 基础数据类型（三）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（二）浮点数Go 提供了两种大小的浮点数 float32 和 float64。float32 提供了大约 6 位小数精度，而 float64 提供了 15 位精度。大多数情况下应该首选 float64，因为 float3…","fields":{"slug":"/go/golang-baisc-type-2/"},"frontmatter":{"date":"October 16, 2019","title":"Golang 基础数据类型（二）","description":null}}},{"node":{"excerpt":"Golang 基础数据类型（一）整数Go 提供了有符号和无符号两种整数运算。有 4 种不同大小的有符号整数——8，16，32，64 位，分别用 int8，int16，int32，int64 类型表示，相应的无符号类型为 uint8，uint16，uint32，uint6…","fields":{"slug":"/go/golang-basic-type-int/"},"frontmatter":{"date":"October 15, 2019","title":"Golang 基础数据类型（一）","description":null}}},{"node":{"excerpt":"Go 程序结构（七）import在一个 Go 程序中，每个 package 都定义了一个唯一的字符串叫做导入路径（）。语言本身并没有定义这些字符串的来源及含义，而是处决于工具如何解析它们。当使用 Go 工具（go tool）时  表示一个文件夹，里面包含一个或多个 Go…","fields":{"slug":"/go/golang-structure-7/"},"frontmatter":{"date":"October 13, 2019","title":"Go 程序结构（七）","description":null}}},{"node":{"excerpt":"Go 程序结构（八）作用域（Scope…","fields":{"slug":"/go/golang-structure-8/"},"frontmatter":{"date":"October 13, 2019","title":"Go 程序结构（八）","description":null}}},{"node":{"excerpt":"Go 程序结构（六）类型声明一个变量或表达式定义了值的特征，比如它的大小、内部展现方式、能够对它进行的操作以及与之相关的一些方法在任何程序中，都有一些变量有相同的展现形式，但是完全不同的含义，比如一个 int…","fields":{"slug":"/go/golang-structure-6/"},"frontmatter":{"date":"October 12, 2019","title":"Go 程序结构（六）","description":null}}},{"node":{"excerpt":"Go 程序结构（五）元组(Tuple)赋值除了前面提到的赋值方式外，Go 还支持另一种赋值方式——元组赋值，允许一次赋值多个变量。所有右边的表达式在任何变量更新之前执行，当某个变量同时出现在等号两边时非常有用，比如交换两个变量时求两个整数的最大公约数计算第 n…","fields":{"slug":"/go/golang-structure-5/"},"frontmatter":{"date":"October 11, 2019","title":"Go 程序结构（五）","description":null}}},{"node":{"excerpt":"Go 程序结构（四）new 函数另一个创建变量的方式是使用内置的  函数。表达式  创建了 T 类型的一个未命名变量，初始化为 T 类型零值，并且返回它的地址使用 new 表达式和原本的创建局部变量然后获取其地址是一样的，但是少了声明变量的过程直接拿到地址，因此 new…","fields":{"slug":"/go/golang-structure-4/"},"frontmatter":{"date":"October 10, 2019","title":"Go 程序结构（四）","description":null}}},{"node":{"excerpt":"Go 程序结构（三）指针一个变量是包含值的存储。声明时创建的变量通过名字来标示，比如 x，但是很多变量只能通过表达式来标示比如 xi 或者 x.f 。所有的这些表达式都读取了变量的值，除非它们出现在赋值语句的左边，这时是新的值赋值给这个变量。一个指针（pointer…","fields":{"slug":"/go/golang-structure-3/"},"frontmatter":{"date":"October 09, 2019","title":"Go 程序结构（三）","description":null}}},{"node":{"excerpt":"Go 程序结构（二）短变量声明在一个方法中，可以使用短变量声明方式用来声明和初始化局部变量。它的形式是, name…","fields":{"slug":"/go/golang-structure-2/"},"frontmatter":{"date":"October 08, 2019","title":"Go 程序结构（二）","description":null}}},{"node":{"excerpt":"Golang 程序结构（一）不管是在 Go 语言还是其他任何语言中，构建大型程序都是从小的基本结构开始。变量存储值，简单的表达式联合成更大的表达式，基本类型集合成数组和结构体，流程控制语句来控制表达式的执行顺序，语句被组成函数进行隔离和复用命名（Names）Go…","fields":{"slug":"/go/golang-structure/"},"frontmatter":{"date":"October 07, 2019","title":"Go 程序结构（一）","description":null}}},{"node":{"excerpt":"MySQL 备份数据库做为 SQL 语句导出通过生成一个文件，这个文件中包含重新创建这个数据库结构的所有 SQL 语句，来进行备份，如果需要也可以包含所有插入数据的 SQL 语句SQL 语句是一种很好的备份方式，SQL…","fields":{"slug":"/mysql/mysql-backup/"},"frontmatter":{"date":"October 06, 2019","title":"MySQL 备份","description":null}}},{"node":{"excerpt":"MySQL 用户变量很多时候我们需要保存 SQL 语句检索的结果，比如想在后面的 SQL 语句中使用这个值，或者想保存这个值在之后显示。使用用户变量允许我们保存结果之后再使用举一个例子，下面的 SQL…","fields":{"slug":"/mysql/mysql-variables/"},"frontmatter":{"date":"October 05, 2019","title":"MySQL 用户变量","description":null}}},{"node":{"excerpt":"实体关系建模示例通过一个大学的学生和课程数据库为例来设计 ER 图表大学数据库中存储关于学生、课程、学生每个学期完成的课程需求列表：学校提供一个或多个项目（programs）一个项目由一个或多个课程组成学生必须注册一个项目学生选择的课程是他的项目的一部分一个项目有名称、项目 ID…","fields":{"slug":"/mysql/mysql-entity-model-example/"},"frontmatter":{"date":"October 04, 2019","title":"实体关系建模示例","description":null}}},{"node":{"excerpt":"…","fields":{"slug":"/mysql/mysql-entity-model/"},"frontmatter":{"date":"October 02, 2019","title":"实体关系模型","description":null}}},{"node":{"excerpt":"数据库模型和设计在创建数据库时，很容易落入快速开发而没有投入足够的时间和努力去做设计的陷阱。这样会导致频繁的重新设计和实现成本错误的实现方式想象一下我们想要创建一个数据库去存储学生的成绩，我们可以创建一个 Student_Grades…","fields":{"slug":"/mysql/msql-model-design/"},"frontmatter":{"date":"October 01, 2019","title":"数据库模型和设计","description":null}}},{"node":{"excerpt":"…","fields":{"slug":"/sql/sql-index/"},"frontmatter":{"date":"September 30, 2019","title":"使用索引","description":null}}},{"node":{"excerpt":"…","fields":{"slug":"/sql/sql-constraint/"},"frontmatter":{"date":"September 29, 2019","title":"使用约束","description":null}}},{"node":{"excerpt":"管理事务处理事务处理使用事务处理（tansaction processing），通过确保成批的 SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性。如果没有错误发生所有 SQL…","fields":{"slug":"/sql/sql-commit/"},"frontmatter":{"date":"September 28, 2019","title":"管理事务处理","description":null}}},{"node":{"excerpt":"使用游标游标SQL 检索操作返回一组被称为结果集的行，这些行都是与 SQL 语句相匹配的行。简单地使用 SELECT 语句，无法得到第一行、下一行或前十行使用游标可以在检索出来的行中前进后退一行或多行。游标是一个存储在数据库服务器上的数据库查询，是 SELECT…","fields":{"slug":"/sql/sql-cursor/"},"frontmatter":{"date":"September 28, 2019","title":"使用游标","description":null}}},{"node":{"excerpt":"使用存储过程（一）什么是存储过程前面我们使用的 SQL 语句大多数是针对一个或多个表的单条语句，但是在现实中经常会遇到一些复杂的操作，需要对多个表执行多条 SQL 语句，可能 SQL 语句执行的顺序也不一样。可以通过单独编写每一条 SQL…","fields":{"slug":"/sql/sql-procedure-1/"},"frontmatter":{"date":"September 26, 2019","title":"使用存储过程（一）","description":null}}},{"node":{"excerpt":"使用视图（二）使用视图重新格式化检索出的数据重新格式化检索出的数据是视图最常见的用途之一。下面的 SQL…","fields":{"slug":"/sql/sql-views-2/"},"frontmatter":{"date":"September 25, 2019","title":"使用视图（二）","description":null}}},{"node":{"excerpt":"Typescript 及其基本类型Typescript 是 Javascript 的超集，可以编译成纯 Javascript。Typescript 中的 type 表示指类型，在 Javascript…","fields":{"slug":"/typescript/types-100/"},"frontmatter":{"date":"September 23, 2019","title":"Typescript 及其基本类型","description":null}}},{"node":{"excerpt":"使用视图（一）视图视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询下面的 SQL…","fields":{"slug":"/sql/sql-views-1/"},"frontmatter":{"date":"September 23, 2019","title":"使用视图（一）","description":null}}},{"node":{"excerpt":"创建和操控表（二）更新表使用 ALTER TABLE 可以更新表的定义，以下是变更表时需要考虑的事情：理想情况下不要在表中包含数据时对其进行变更所有数据库都允许给现有的表增加列，但是对所增加列的数据类型以及 NULL 和 DEFAULT…","fields":{"slug":"/sql/sql-create-table-2/"},"frontmatter":{"date":"September 22, 2019","title":"创建和操控表（二）","description":null}}},{"node":{"excerpt":"创建和操控表（一）SQL 不仅可以对表的数据进行操纵，还可以对数据库和表本身进行操作，包括表本身的创建和处理表创建基础在 SQL 中可以使用 CREATE TABLE 来创建表。创建表是必须给出下列信息：新表的名字，跟在 CREATE TABLE…","fields":{"slug":"/sql/sql-create-table/"},"frontmatter":{"date":"September 21, 2019","title":"创建和操控表（一）","description":null}}},{"node":{"excerpt":"更新和删除数据更新数据更新表的数据可以用 UPDATE 语句。UPDATE 语句有两种使用方式：更新表中特定的行更新表中所有行UPDATE 语句由三部分组成：需要更新的表列名和它的新值需要更新哪些行的过滤条件输入上面的 UPDATE 语句对 Customers 表中 cust…","fields":{"slug":"/sql/sql-update-delete/"},"frontmatter":{"date":"September 20, 2019","title":"更新和删除数据","description":null}}},{"node":{"excerpt":"数据插入在 SQL 中使用 INSERT 将行插入或添加到数据库的表中，插入数据的几种方式：插入完整的行插入行的一部分插入某些查询的结果插入完整的行输入上面的 SQL 语句将一条新的顾客数据插入到了 Customers 表中，在 VALUE…","fields":{"slug":"/sql/sql-insert-1/"},"frontmatter":{"date":"September 19, 2019","title":"数据插入","description":null}}},{"node":{"excerpt":"组合查询（二）UNION 规则UNION 使用起来很简单，但是需要注意以下规则UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间使用关键字 UNION 分隔，比如有4条 SELECT，则需要3个 UNION 关键字 UNION…","fields":{"slug":"/sql/sql-union-2/"},"frontmatter":{"date":"September 18, 2019","title":"组合查询（二）","description":null}}},{"node":{"excerpt":"组合查询（一）组合查询大多数 SQL 查询语句都是使用单条 SELECT 语句来查询数据，但是 SQL 中也支持执行多个查询即多条 SELECT 语句，并且将结果作为一个查询集合返回，这样的查询被称为组合查询（compound query…","fields":{"slug":"/sql/sql-union-1/"},"frontmatter":{"date":"September 17, 2019","title":"组合查询（一）","description":null}}},{"node":{"excerpt":"…","fields":{"slug":"/sql/sql-join-3/"},"frontmatter":{"date":"September 16, 2019","title":"联结表（三）","description":null}}},{"node":{"excerpt":"联结表（二）联结类型除了内联结或等值联结外，还有三种联结方式：自联结（self-join）、自然联结（natural join）和外联结（outer join）使用表别名SQL 语句中除了可以给列名和计算字段取别名外，还可以对表名取别名。给表取别名主要原因有：缩短 SQL…","fields":{"slug":"/sql/sql-join-2/"},"frontmatter":{"date":"September 15, 2019","title":"联结表（二）","description":null}}},{"node":{"excerpt":"联结表（一）联结（join）表是 SQL 中最强大的功能之一，很好的理解联结表及其语法是学习 SQL…","fields":{"slug":"/sql/sql-join-1/"},"frontmatter":{"date":"September 14, 2019","title":"联结表（一）","description":null}}},{"node":{"excerpt":"使用子查询在 SQL 语句中允许在查询语句中嵌套其他的查询语句，即子查询（subquery）利用子查询进行过滤现在存在三个表，Orders 表储存订单编号、客户 ID、订单日期，OrderItems 表储存订单物品的相关信息，Customer…","fields":{"slug":"/sql/sql-child-query/"},"frontmatter":{"date":"September 13, 2019","title":"使用子查询","description":null}}},{"node":{"excerpt":"分组数据（二）分组过滤GROUP BY 除了能对数据进行分组外，还可以对分组进行过滤，指定包含哪些分组，排除哪些分组与 WHERE 子句的不同是 WHERE 子句过滤的是行而不是分组。SQL 中提供了对分组进行过滤的子句 HAVING。HAVING 非常类似与 WHERE…","fields":{"slug":"/sql/sql-group-2/"},"frontmatter":{"date":"September 12, 2019","title":"分组数据（二）","description":null}}},{"node":{"excerpt":"分组数据（一）SQL 中的聚集函数可以汇总数据，能够计算平均值、最大值、最小值等，所有的计算都是表的所有数据或者匹配特定 WHERE 子句的数据，比如：输入输出如果要返回每个供应商的产品数目，或者返回1…","fields":{"slug":"/sql/sql-group-1/"},"frontmatter":{"date":"September 11, 2019","title":"分组数据（一）","description":null}}},{"node":{"excerpt":"聚集函数（三）前面介绍的几个聚集函数都可以如下使用：对所有行执行计算，可以指定指定特定行或者所有行（*）通过指定 DISTINCT 参数，可以只包含不同的值下面使用 DISTINCT 参数，计算平均值输入输出上面的 AVG(DISTINCT prod_price…","fields":{"slug":"/sql/sql-collect-function-3/"},"frontmatter":{"date":"September 10, 2019","title":"聚集函数（三）","description":null}}},{"node":{"excerpt":"集聚函数（二）MAX() 函数MAX() 函数返回指定列中的最大值。MAX() 要求指定列名输入输出上面的 SQL 语句中方 MAX(prod_price) 返回表中物品的最大价格MAX() 函数会忽略值为 NULL 的行MIN() 函数MIN() 函数与 MAX…","fields":{"slug":"/sql/sql-collect-function-2/"},"frontmatter":{"date":"September 09, 2019","title":"集聚函数（二）","description":null}}},{"node":{"excerpt":"集聚函数（一）很多时候我们需要汇总数据而不是检索数据，SQL…","fields":{"slug":"/sql/sql-collect-function/"},"frontmatter":{"date":"September 08, 2019","title":"集聚函数（一）","description":null}}},{"node":{"excerpt":"使用函数处理数据（一）与大多数其他编程语言一样，SQL 也支持函数来处理数据，为数据的转换和处理提供方便对于不同类型的函数除了少数被主要的数据库支持，大部分函数虽然功能相同但是函数的名称和语法可能完全不同SQL 中的函数类型大部分 SQL…","fields":{"slug":"/sql/sql-function/"},"frontmatter":{"date":"September 06, 2019","title":"使用函数处理数据（一）","description":null}}},{"node":{"excerpt":"创建计算字段一般储存在表中数据可能不是应用程序所需要的格式，我们需要对数据库中检索的字段进行转换、计算或者格式化后再返回给应用程序，这时就可以使用计算字段拼接字段可以通过拼接字段来使用计算字段。我们现在有一个 Vendors…","fields":{"slug":"/sql/sql-computed-field/"},"frontmatter":{"date":"September 05, 2019","title":"创建计算字段","description":null}}},{"node":{"excerpt":"用通配符进行过滤（二）下划线（_）通配符下划线通配符也是一个非常有用的通配符，它与 % 通配符的用途很相似，但是它只匹配单个字符，而不是多个字符。输入输出上面的 SQL 语句使用了两个 _ 通配符匹配，只有同时匹配两个操作符的行会被检索出来，比如第一行匹配 1…","fields":{"slug":"/sql/sql-select-like-2/"},"frontmatter":{"date":"September 04, 2019","title":"用通配符进行过滤（二）","description":null}}},{"node":{"excerpt":"使用通配符进行过滤使用 LIKE 操作符进行通配搜索，可以对数据进行复杂的过滤LIKE 操作符前面介绍的几种操作符，不管是匹配一个值、多个值，还是某个范围的值，都是根据已知的值进行比较，如果要搜索包含某个文本的值就无法继续比较了，这时就要用到 LIKE 通配符了。LIKE…","fields":{"slug":"/sql/sql-select-like/"},"frontmatter":{"date":"September 03, 2019","title":"使用通配符进行过滤","description":null}}},{"node":{"excerpt":"数据过滤（三）IN 操作符IN 操作符用来指定特定的条件范围，范围中的每个条件都可以进行匹配。IN 取一组由逗号分隔，括在圆括号中的合法值。输入输出SmartSelect_20190902-082604_Termux上面的 SELECT 语句检索由供应商 DLL01 和 BRS…","fields":{"slug":"/sql/sql-select-filter-3/"},"frontmatter":{"date":"September 02, 2019","title":"数据过滤（三）","description":null}}},{"node":{"excerpt":"过滤数据（二）组合 WHERE 子句为了进行更强的过滤控制，SQL 允许多个 WHRER 子句组合，使用 AND 或 OR 分隔。AND 操作符如果要对多个列进行过滤，可以使用 AND 操作符添加多个条件输入输出上面的 SQL 语句检索出供应商为 DLL01 且产品价格小于…","fields":{"slug":"/sql/sql-select-filter-2/"},"frontmatter":{"date":"September 01, 2019","title":"过滤数据（二）","description":null}}},{"node":{"excerpt":"过滤数据（一）使用 WHERE 子句数据表一般包含大量的数据，而通常只需要根据特定的要求检索表中的部分行，而不是所有行。在 SELECT 语句中，数据根据 WHERE 子句中特定的搜索条件进行过滤。输入输出上面的 SQL 语句检索两个列，但是只返回 prod_price 为…","fields":{"slug":"/sql/sql-select-filter/"},"frontmatter":{"date":"August 31, 2019","title":"过滤数据（一）","description":null}}},{"node":{"excerpt":"排序检索数据使用 SELECT 语句的 ORDER BY 子句可以对检索数据进行排序排序数据使用 SQL…","fields":{"slug":"/sql/sql-select-order_1/"},"frontmatter":{"date":"August 30, 2019","title":"排序检索数据","description":null}}},{"node":{"excerpt":"数据检索（三）限制检索结果SELECT 语句返回指定表中所有匹配的行，如果只想返回第一行或者一定数量的行，在不同数据库中这一 SQL 实现并不相同如果使用 SQL Server 和 Access，可以通过 TOP 关键字来限制最多返回多少行上面的代码使用 SELECT TOP…","fields":{"slug":"/sql/sql-select_3/"},"frontmatter":{"date":"August 29, 2019","title":"数据检索（三）","description":null}}},{"node":{"excerpt":"数据检索（一）使用 SELECT 语句检索一个或多个数据列SELECT 语句SQL 语句是由简单英语单词构成，这些单词被称为关键词，每一个 SQL 语句都是由一个或多个关键词构成。SELECT 语句是 SQL 中最常用的语句它的作用是在一个或多个表中检索信息使用 SELECT…","fields":{"slug":"/sql/sql-select_1/"},"frontmatter":{"date":"August 27, 2019","title":"数据检索（一）","description":null}}},{"node":{"excerpt":"数据检索（二）检索所有列除了检索所需要的列， SELECT…","fields":{"slug":"/sql/sql-select_2/"},"frontmatter":{"date":"August 27, 2019","title":"数据检索（二）","description":null}}},{"node":{"excerpt":"…","fields":{"slug":"/sql/know-sql/"},"frontmatter":{"date":"August 26, 2019","title":"数据库基础","description":"了解数据库表、列、行以及主键"}}},{"node":{"excerpt":"Node.js 日志中间件 morganmorgan 是一个 Node.js 日志中间件，下面将介绍如何使用 morgan基本使用上面的代码创建了一个 express web 服务，使用 morgan 中间件打印每一次请求的日志调用 方法会创建一个日志中间件，参数 format…","fields":{"slug":"/promise/log-morgan/"},"frontmatter":{"date":"August 25, 2019","title":"Node.js 日志中间件 morgan","description":null}}},{"node":{"excerpt":"使用 Visual Studio Code 调试代码Visual Studio Code（简称 VS Code） 是一个跨平台、轻量级代码编辑器。VS Code 内置的对 Node.js 的 debug 支持，能够 debug Javascript 和 Typescript…","fields":{"slug":"/promise/vscode-debug/"},"frontmatter":{"date":"August 23, 2019","title":"使用 Visual Studio Code 调试代码","description":null}}},{"node":{"excerpt":"使用 Chrome DevTools 调试 Node.js 程序代码调试是程序员的必备技能，选择适合的工具能够极大的提高调试的效率。Node.js 6.3 及以上版本内置了一个调试器，可以结合 Chrome DevTools 使用来调试代码。创建测试代码上面的代码使用 koa…","fields":{"slug":"/promise/devtools/"},"frontmatter":{"date":"August 22, 2019","title":"使用 Chrome DevTools 调试 Node.js 程序","description":null}}},{"node":{"excerpt":"在 Node.js 中使用 Source Map为了减少代码体积或者编译成兼容性更好的低版本代码，通常需要压缩和编译代码，但是会导致在出现错误时无法对错误进行定位，通过 Source Map 工具可以解决这个问题。下面将会介绍 uglify-es 和 tyescript…","fields":{"slug":"/promise/source-map/"},"frontmatter":{"date":"August 21, 2019","title":"在 Node.js 中使用 Source Map","description":null}}},{"node":{"excerpt":"Node.js 错误栈当程序出现错误是通常会抛出错误栈（error.stack），通过错误栈可以定位到出错的代码。 Node.js 的 Error 对象中包含错误栈（stack）以及 name、message 等属性。Node.js 中内置的 Error 类型Error…","fields":{"slug":"/promise/erro-stack/"},"frontmatter":{"date":"August 20, 2019","title":"Node.js 错误栈","description":null}}},{"node":{"excerpt":"Promise 规范及实现原理在 Javascript 中异步和事件监听都是通过回调进行传值，回调过多很容易形成‘回调地狱’，比如：上面的代码依次执行 step1，step2，step3，step…","fields":{"slug":"/promise/promise-standard/"},"frontmatter":{"date":"August 18, 2019","title":"Promise 规范及实现原理","description":null}}},{"node":{"excerpt":"Node.js 内存调试之 cpu-memory-monitor前面介绍了用 heapdump 和 memwatch-next 来调试内存，但是它们需要手动触发 Core Dump，在实际使用时并不知道什么时候去触发，而 cpu-memory-monitor 可以用来监控 CPU…","fields":{"slug":"/debug/cpu-monitor/"},"frontmatter":{"date":"August 17, 2019","title":"Node.js 内存调试之 cpu-memory-monitor","description":null}}},{"node":{"excerpt":"Node.js 内存调试之 memwatch-nextmemwatch-next 是一个用来监测内存泄露和比较堆信息的模块，下面介绍如何使用 memwatch-next创建测试代码每次请求时注册 10000 个 request 事件来引发内存泄露，然后手动触发一次 GC…","fields":{"slug":"/debug/memwatch-next/"},"frontmatter":{"date":"August 16, 2019","title":"Node.js 内存调试之 memwatch-next","description":null}}},{"node":{"excerpt":"Node.js 内存调试之 heapdumpheapdump 是一个 dump V8 堆信息的工具，前面提到的 v8-profiler 也有堆信息的功能，这两个工具的原理是一样的，但是 heapdump 更简单一点使用 heapdump…","fields":{"slug":"/debug/heapdump/"},"frontmatter":{"date":"August 15, 2019","title":"Node.js 内存调试之 heapdump","description":null}}},{"node":{"excerpt":"Node.js 内存调试之 gcore 与 llnode内存泄露是 Node.js 常见的问题之一，不当的全局缓存、事件监听、闭包等都可能导致内存泄露，如何检测、定位内存泄露是非常重要的话题什么是 Core Dump…","fields":{"slug":"/debug/gcore_llnode/"},"frontmatter":{"date":"August 13, 2019","title":"Node.js 内存调试之 gcore 与 llnode","description":null}}},{"node":{"excerpt":"使用 Tick Processor 分析 CPU 使用情况Tick Processor 是 v8 内置的一个性能分析工具，可以记录 Javascript、C、C++代码的堆栈信息，该功能默认是关闭的，可以通过添加命令行参数 —prof 开启创建测试代码创建了一个 hash…","fields":{"slug":"/debug/tick-processor/"},"frontmatter":{"date":"August 13, 2019","title":"使用 Tick Processor 分析 CPU 使用情况","description":null}}},{"node":{"excerpt":"使用 v8-profiler 分析 CPU 使用情况Node.js 是基于 Chrome 的 V8 引擎，V8 暴露了一些 profiler API 用来分析 CPU 的使用情况创建测试代码在  get 请求里面使用  同步方法获取 hash 值，进行 CPU…","fields":{"slug":"/debug/v8-profiler/"},"frontmatter":{"date":"August 10, 2019","title":"使用 v8-profiler 分析 CPU 使用情况","description":null}}},{"node":{"excerpt":"perf 与 火焰图（FlameGraph）Node.js 是单线程异步的 I/O 模型，在接受到请求时并不是每个请求启动一个线程，如果有一个任务长时间占用 CPU 整个应用就会卡住，无非处理其他请求。火焰图（FlameGraph）可以将 CPU…","fields":{"slug":"/debug/perf-flame-graph/"},"frontmatter":{"date":"August 08, 2019","title":"理解 perf 与 火焰图（FlameGraph）","description":null}}},{"node":{"excerpt":"使用 Node.js 创建 Todo 命令行程序完成一个命令行小程序，具有以下功能：todo new        创建一个 todotodo get        获取 todo 列表todo complete   完成一个 todotodo help…","fields":{"slug":"/command/nodejs-command-todo/"},"frontmatter":{"date":"August 06, 2019","title":"使用 Node.js 编写命令行程序（二）","description":null}}},{"node":{"excerpt":"使用 Node.js 编写命令行程序（一）Node.js 命令行工具应用非常广泛，比如前端框架的脚手架 Angular CLI、 Vue CLI 、Create React App, 以及打包编译工具webpack、babel等，下面将介绍如何开始创建一个 Node.js…","fields":{"slug":"/command/command-1/"},"frontmatter":{"date":"August 05, 2019","title":"使用 Node.js 编写命令行程序（—）","description":"Node.js 命令行程序简介以及命令行参数的使用"}}},{"node":{"excerpt":"Node.js 简介以及使用起源Ryan Dahl 2009 年创建2012 年离开 Node.js 社区, 2018年创建 DenoNode.js 组成\n\n\n\nV8\n由 Google 为 Chrome 开发的Javascript 引擎，核心工程师 Lars Bak…","fields":{"slug":"/share/nodejs/"},"frontmatter":{"date":"August 04, 2019","title":"Node.js 分享","description":null}}},{"node":{"excerpt":"Node.js 的 集群（Cluster） 和 线程（Worker Threads）Node.js 是天生的单线程运行模式，运行在单核 CPU 上，而现代计算机基本都是多核的 CPU。Node.js 提供了两种方式来充分利用多核 CPU： 集群（Cluster…","fields":{"slug":"/deploy/nodejs-cluster/"},"frontmatter":{"date":"August 03, 2019","title":"Node.js 的 集群（Cluster） 和 线程（Worker Threads）","description":null}}},{"node":{"excerpt":"Node.js 程序的运维与部署每一种 web 技术都有各种增强稳定性和提供性能的技巧，Node.js 也不例外。web 程序如何部署，如何选择部署环境，如何保证在线时长也是一个至关重要的安置 Node.js 程序可靠和可扩展的运行 Node.js…","fields":{"slug":"/deploy/nodejs-deploy/"},"frontmatter":{"date":"August 02, 2019","title":"Node.js 程序的运维与部署","description":null}}},{"node":{"excerpt":"Cypress 测试框架的核心概念查询元素类似于 jQuery 的选择器, 但是不会同步返回元素，比如:Cypress 里面不会直接返回元素，而是会包装一层重试和超时逻辑，使用 .then 方法异步获取元素设置超时当查找的元素不存在时，cypress…","fields":{"slug":"/test/nodejs-cypress-core/"},"frontmatter":{"date":"August 01, 2019","title":"Cypress 测试框架的核心概念","description":null}}},{"node":{"excerpt":"Node.js 端到端测试框架 Cypress使用 Cypress 能够对浏览器中运行的任何内容进行快速，简单和可靠的测试对比 Selenium 运行在浏览器之外，Cypress运行在浏览器里面能够直接获取 document、window 等 Javascript…","fields":{"slug":"/test/nodejs-cypress/"},"frontmatter":{"date":"July 31, 2019","title":"Node.js 端到端测试框架 Cypress","description":null}}},{"node":{"excerpt":"Sinon.js 的探测器和存根Sinon.js 是用来编写测试探测器(spies)、存根(stubs)和模拟对象(mocks)的 Javascript 库，能够运行在任何 Node.js…","fields":{"slug":"/test/nodejs-sinon/"},"frontmatter":{"date":"July 30, 2019","title":"Node.js 测试之 Sinon.js 的探测器和存根","description":null}}},{"node":{"excerpt":"Node.js 断言库 chaichai 是一个 BDD / TDD 风格的断言库，能在 Node.js 和 浏览器内运行。chai 有三个接口 should、expect 和 assert，should、expect 为 BDD 风格，assert 为 TDD…","fields":{"slug":"/test/nodejs-chai/"},"frontmatter":{"date":"July 29, 2019","title":"Node.js 断言库 chai","description":null}}},{"node":{"excerpt":"Node.js 测试框架 MochaMocha 是一个功能丰富的 Javascript 测试框架，能够运行在 Node.js 和浏览器中，能够简单方便的对异步流程进行测试 安装 Mocha创建 test 目录，在 package.json 里面添加执行脚步执行  mocha…","fields":{"slug":"/test/nodejs-mocha/"},"frontmatter":{"date":"July 28, 2019","title":"Node.js 测试框架 Mocha","description":null}}},{"node":{"excerpt":"Node.js 单元测试Node.js 自带了 assert 模块，是大多数单元测试的基础，很多第三方测试框架都用到了 assert 模块。先定义一个简单的待办事项程序（ Todo ） 程序，然后使用 assert 模块对代码进行单元测试定义 Todo…","fields":{"slug":"/test/nodejs-unit-test/"},"frontmatter":{"date":"July 27, 2019","title":"Node.js 单元测试","description":null}}},{"node":{"excerpt":"嵌入式数据库 LevelDB嵌入式数据库是嵌入在程序的进程中的，不需要依赖外部的服务器。在程序需要做到自包含时候比如移动端或者桌面程序，只能选择嵌入式数据库。Node.js 中常用的嵌入式数据库有 SQLite、LevelDB、RocksDB等，除了 SQLite…","fields":{"slug":"/database/leveldb/"},"frontmatter":{"date":"July 26, 2019","title":"嵌入式数据库 LevelDB","description":null}}},{"node":{"excerpt":"在 Node.js 中使用 RedisRedis 是非常热门的结构化内存数据库，使用 key/value 来储存数据，其中 value 值包括以下类型：string 字符串hash 哈希表list 列表sets 集合sorted sets 有序集Redis…","fields":{"slug":"/database/redis/"},"frontmatter":{"date":"July 25, 2019","title":"在 Node.js 中使用 Redis","description":null}}},{"node":{"excerpt":"MongoDB 数据库更新和删除操作更新文档MongoDB 中提供了三个方法更新文档Collection.updateOneCollection.updateManyCollection.replaceOne…","fields":{"slug":"/database/mongo-ud/"},"frontmatter":{"date":"July 24, 2019","title":"MongoDB 数据库更新和删除操作","description":null}}},{"node":{"excerpt":"MongoDB 数据库插入和查询操作插入文档如果当前集合不存在，插入操作将会创建集合通过  在集合中插入一个文档 返回的 Promise 中提供了 result 对象， result.insertedId 为新插入文档的 _id…","fields":{"slug":"/database/MongoDB-CRUD/"},"frontmatter":{"date":"July 23, 2019","title":"MongoDB 数据库插入和查询操作","description":null}}},{"node":{"excerpt":"MongoDB 简介MongoDB 是面向对象的分布式数据库，基于文档储存，将文档储存在无模式的数据集中，不需要为预先文档定义模式，同一个文档中也不用遵循相同的模式，因此拥有很高的灵活性。安装 MongoDB安装 Node.js 客户端安装 MongoDB 官方 npm…","fields":{"slug":"/database/mongodb/"},"frontmatter":{"date":"July 22, 2019","title":"MongoDB 简介","description":null}}},{"node":{"excerpt":"SQL 查询构建器 KnexKnex 是一个功能完备的SQL查询构建器支持Postgres, MSSQL, MySQL, MariaDB, SQLite3, Oracle等数据库。\nKnex 既支持传统的 Node.js 风格的回调，也支持 Promise…","fields":{"slug":"/database/kenx/"},"frontmatter":{"date":"July 21, 2019","title":"查询构建器 Knex","description":null}}},{"node":{"excerpt":"PostgreSQL 简单使用PostgreSQL 是开源、强大、且功能丰富的关系型数据库安装 PostgreSQL最简单的方式是使用 Docker 安装 环境变量用来设置数据库的密码， 用来设置数据库的用户名，然后将数据库数据映射到宿主机通过日志查看是否启动postgres…","fields":{"slug":"/database/PostgreSQL/"},"frontmatter":{"date":"July 20, 2019","title":"PostgreSQL 简单使用","description":null}}},{"node":{"excerpt":"Express Web 之创建 REST API在之前的基础上实现以下功能：设计一个让用户显示、提交和移除消息列表的 API添加基本认证实现路由通过 JSON 响应设计 API…","fields":{"slug":"/nodejs/express-rest-api/"},"frontmatter":{"date":"July 18, 2019","title":"Express Web 之创建 REST API","description":null}}},{"node":{"excerpt":"Express Web…","fields":{"slug":"/nodejs/express-login/"},"frontmatter":{"date":"July 17, 2019","title":"Express Web 之用户登录","description":null}}},{"node":{"excerpt":"Express Web 之用户注册上一篇中完成了用户的认证流程，在此基础上我们继续构建用户的注册流程需要完成以下功能：创建注册页面创建注册接口储存用户注册数据创建注册页面添加路由访问http://localhost:3000/users/register…","fields":{"slug":"/nodejs/express-register/"},"frontmatter":{"date":"July 16, 2019","title":"Express Web 之用户注册","description":null}}},{"node":{"excerpt":"Express Web 之用户认证使用 Express 从头开始创建一个认证系统，包括注册、登录、认证功能。创建用户模型调用  方法，先检查用户  是否纯存在，如果存在就调用  方法更新用户信息，如果不存在就创建新的用户给密码加哈希安装 测试用户模型逻辑在 redis…","fields":{"slug":"/nodejs/express-auth/"},"frontmatter":{"date":"July 15, 2019","title":"Express Web 之用户认证","description":null}}},{"node":{"excerpt":"Express Web 之使用中间件校验表单在校验表单之前，首先要实现表单提交功能，然后使用中间件校验表单创建表单模型安装 Redis借助 Redis 和 ES…","fields":{"slug":"/nodejs/express-redis/"},"frontmatter":{"date":"July 14, 2019","title":"Express Web 之使用中间件校验表单","description":null}}},{"node":{"excerpt":"express 环境配置与模版渲染上一篇中我们创建了 express web 程序并定义了路由，本篇我们继续配置 express 环境以及使用模版渲染环境配置express 自带了一个极简的环境配置系统，由以下几个方法组成：app.set()app.get()app…","fields":{"slug":"/nodejs/express-view-render/"},"frontmatter":{"date":"July 13, 2019","title":"Express 环境配置与模版渲染","description":null}}},{"node":{"excerpt":"Node.js Web 之深入了解 express 框架express 是 Node.js 中最流行的 Web 框架，使用起来很简单但是功能强大。生成 express 程序 是一个 express 程序生成器，安装完成后可通过  查看其功能生成 shoutbox…","fields":{"slug":"/nodejs/nodejs-understand-express/"},"frontmatter":{"date":"July 12, 2019","title":"Node.js Web 之深入了解 express 框架","description":null}}},{"node":{"excerpt":"Node.js Web 之深入了解 Connect 中间件（二）上一篇中介绍了 Connect 中间件的工作机制，本篇继续介绍如何组合中间件、中间件的顺序以及创建可配置的中间件组合中间件Connect 中使用 use…","fields":{"slug":"/nodejs/nodejs-understand-connect-2/"},"frontmatter":{"date":"July 10, 2019","title":"Node.js Web 之深入了解 Connect 中间件（二）","description":null}}},{"node":{"excerpt":"Node.js Web 之深入了解 Connect 中间件（一）connect 是一个基于 HTTP 服务器的工具集，它提供了一种新的组织代码的方式来与请求和响应对象进行交互，称为中间件（书上原话）。通俗的来说，http…","fields":{"slug":"/nodejs/nodejs-understand-connect/"},"frontmatter":{"date":"July 09, 2019","title":"Node.js Web 之深入了解 Connect 中间件（一）","description":null}}},{"node":{"excerpt":"Node.js Web 框架 NestNest 是一个用来构建高效、可扩展的 Node.js Web 服务的框架，使用 Typescript 编写并结合了OOP (面向对象), FP (函数式), and FRP (响应式编程)等编程范式Nest…","fields":{"slug":"/nodejs/nodejs-web-framework-nest/"},"frontmatter":{"date":"July 07, 2019","title":"Node.js Web 框架 Nest","description":null}}},{"node":{"excerpt":"使用函数处理数据（二）时间和日历处理函数每个数据库在表中存储日期和时间类型的数据都有自己的特殊形式，日期和时间值以特殊的格式储存，以便能够快速有效的排序和过滤，并且可以节省物理存储空间以下的 SQL 是在 SQL Server 中检索 Orders 表中 201…","fields":{"slug":"/sql/sql-function-2/"},"frontmatter":{"date":"July 07, 2019","title":"使用函数处理数据（二）","description":null}}},{"node":{"excerpt":"Node.js Web 框架之 SailsSails 是 Node.js 中最流行的 MVC 框架，类似于 Ruby on Rails。使用 Sails 可以轻松构建企业级的 Node.js Web 服务特点Sails 内置强大的 ROM…","fields":{"slug":"/nodejs/nodejs-web-framework-sails/"},"frontmatter":{"date":"July 06, 2019","title":"Node.js Web 框架之 Sails","description":null}}},{"node":{"excerpt":"Node.js Web 框架之 RestifyRestify Web 服务框架，专门针对构建语义正确的 RESTful Web 服务进行了优化，可以大规模地用于生产安装创建 Web 服务curl 访问添加路由Restify 路由类似于 Express，用 HTTP…","fields":{"slug":"/nodejs/nodejs-web-framework-restify/"},"frontmatter":{"date":"July 05, 2019","title":"Node.js Web 框架之 Restify","description":null}}},{"node":{"excerpt":"Node.js Web 框架比较当我们开始构建 Web 服务器时，首先要选择一个适合的框架，各个框架有不同的优缺点以及应用场景，在选择之前最好了解一下常见的框架，以做出最好的选择。接下来会简单介绍以下几个 Web 框架：KoaHapiSailsRestifyNestKoaKoa…","fields":{"slug":"/nodejs/nodejs-web-framework/"},"frontmatter":{"date":"July 03, 2019","title":"Node.js Web 框架比较","description":"对比了几种常见的 Node.js Web 框架的优缺点以及使用场景"}}},{"node":{"excerpt":"在 Node.js 中使用模版渲染Node.js 中模版引擎有很多种，这里使用简单易学的EJS模版什么是 EJSEJS 中的 E 是 “Embedded”，即嵌入式 Javascript，是一个使用纯 Javascript 生成 HTML 的模版语言安装 EJS…","fields":{"slug":"/nodejs/what-is-nodejs-ejs/"},"frontmatter":{"date":"July 02, 2019","title":"在 Node.js 中使用模版渲染","description":null}}},{"node":{"excerpt":"在 Node.js Web 程序中添加数据库Node.js 支持多种常用的数据库，比如 MySQL、PostgreSQL、Redis、SQLite 等，这里使用非常简单的、适合入门的 SQLite 数据库定义数据模型 API安装 sqlite3 模块连接到 sqlite…","fields":{"slug":"/nodejs/what-is-node-js-sql/"},"frontmatter":{"date":"July 01, 2019","title":"在 Node.js Web 程序中添加数据库","description":"在 Node.js 使用 SQLite 作为数据库系统，实现对数据的查询、存储和删除"}}},{"node":{"excerpt":"搭建 RESTful Web 服务本文内容：创建一个 Node.js Web 程序搭建 RESTful 服务了解 Node.js Web 程序的结构通常 Node.js 程序的目录如下：package.json —— 包含程序的依赖列表和程序的运行脚本public…","fields":{"slug":"/nodejs/what-is-node-web/"},"frontmatter":{"date":"June 30, 2019","title":"Node.js Web程序之搭建 RESTful Web 服务","description":"搭建 RESTful Web 服务"}}},{"node":{"excerpt":"Node.js…","fields":{"slug":"/nodejs/async-parallel/"},"frontmatter":{"date":"June 29, 2019","title":"Node.js异步控制流程之并行流程","description":null}}},{"node":{"excerpt":"Node.js的异步流程控制以及串行流程的实现在异步程序的执行过程中，有些任务可能随时发生，根程序中其他部分在做什么没关系，什么时候做这些任务都不会出问题。但是也有一些任务只能在某些特定的任务之前或之后执行Node.js…","fields":{"slug":"/nodejs/async-flow/"},"frontmatter":{"date":"June 28, 2019","title":"Node.js的异步流程控制以及串行流程的实现","description":"Node.js的异步流程控制以及串行流程的实现"}}},{"node":{"excerpt":"Node.js 异步编程之事件监听在 Node.js 中通过在事件发射器(EventEmitter)中绑定事件监听函数来处理重复性事件。一些 Node.js 中的重要组件比如 HTTP、TCP 以及流模块都被做成了事件发射器。也可以定义自己的事件发射器。使用 net…","fields":{"slug":"/nodejs/aysnc-program-event/"},"frontmatter":{"date":"June 27, 2019","title":"Node.js异步编程之事件监听","description":"在 Node.js 中通过在事件发射器(EventEmitter)中绑定事件监听函数来处理重复性事件。一些 Node.js 中的重要组件比如 HTTP、TCP 以及流模块都被做成了事件发射器。也可以定义自己的事件发射器。"}}},{"node":{"excerpt":"Node.js 中的异步编程Node.js 中异步编程是通过事件触发响应逻辑，在 Node.js…","fields":{"slug":"/nodejs/async-program/"},"frontmatter":{"date":"June 26, 2019","title":"Node.js中的异步编程以及回调的使用","description":"Node.js中的两种异步编程方式回调、事件监听的介绍以及回调的使用"}}},{"node":{"excerpt":"Node.js编程基础Node.js核心模块对Javascript有一点了解的都知道，Javascript没有与操作系统互交的能力，比如文件I/O、TCP/IP网络等，Node.js中的核心模块为Javascript添加了这些功能，使它可以用来编写服务端程序文件系统模块：fs…","fields":{"slug":"/nodejs/node-fundamentals/"},"frontmatter":{"date":"June 25, 2019","title":"Node.js编程基础","description":"Node.js的核心模块简介，Node.js中的代码组织方式"}}},{"node":{"excerpt":"Node.js 的安装以及 npm 包管理工具的使用Node.js 的版本长期支持版 LTS，18 个月的更新支持，12 个月的维护支持当前发布版 Current，6 个月的更新支持，单数版（比如 9，11）6 个月后不再支持，双数版（比如 10，12）…","fields":{"slug":"/nodejs/install-project/"},"frontmatter":{"date":"June 24, 2019","title":"Node.js的安装以及npm包管理工具的使用","description":"Node.js的安装以及npm包管理工具的使用"}}},{"node":{"excerpt":"Node.js简介Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性。非阻塞 I/O 模型Node.js使用事件驱动（event…","fields":{"slug":"/nodejs/whynodejs/"},"frontmatter":{"date":"June 23, 2019","title":"Node.js简介","description":"什么是Node.js以及Node.js的非阻塞I/O模型、事件驱动、应用场景"}}},{"node":{"excerpt":"如何使用Github Pages搭建个人博客Github Pages是GitHub的上的一个功能，可以用来存放静态的网页，适合存放项目文档、博客等，最大的优势是可以结合git对文档、博客等做版本管理GitHub Pages的使用在GitHub…","fields":{"slug":"/other/createblog/"},"frontmatter":{"date":"June 22, 2019","title":"搭建个人博客","description":"如何使用github pages搭建自己的博客系统"}}},{"node":{"excerpt":"LeetCode初级算法题—最大子序和最大子序和问题描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:分析最简单的情况数组长度为1数组长度为2时连续子数组有-2,-2, 1,1,对比长度为1时，增加了两个连续子数组-…","fields":{"slug":"/leetcode/maxsubarray/"},"frontmatter":{"date":"June 21, 2019","title":"LeetCode算法题--最大子序和","description":"给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和"}}},{"node":{"excerpt":"索引类型与映射类型索引类型通过keyof(索引类型查询操作符)关键词,可以拿到类型的所有属性即索引K的类型为T所有的属性的联合类型，这时K等同于再通过in关键词来索引其中TP是索引访问操作符，通过像索引一样查询T中对应的类型。M的类型为, M…","fields":{"slug":"/typescript/maptype/"},"frontmatter":{"date":"June 20, 2019","title":"Typescript系列(六)：索引类型与映射类型","description":"本篇介绍typescript中的索引类型与映射类型"}}},{"node":{"excerpt":"泛型及泛型的约束泛型是什么先从一个例子开始：对于log函数有了类型限定后message参数只能为string类型，那么函数的通用性不够，比如要打印一个数字，会报类型错误，一种方式是将message设置为any类型此时log…","fields":{"slug":"/typescript/generic/"},"frontmatter":{"date":"June 19, 2019","title":"Typescript系列(五)：泛型及泛型的约束","description":"本篇介绍typescript中的泛型及泛型的约束"}}},{"node":{"excerpt":"类型别名类型别名就是给类型起一个新的名字，可以作用于任意类型包括基本类型、class类型、接口类型等，但是相对于接口来说不能用于继承给基本类型定义别名：那么name的类型依然是string…","fields":{"slug":"/typescript/types/"},"frontmatter":{"date":"June 18, 2019","title":"Typescript系列(四)：类型别名以及交叉类型、联合类型","description":"本篇介绍typescript中的类型别名及交叉类型、联合类型的定义使用"}}},{"node":{"excerpt":"本篇为Typescript系列的第三篇，主要内容为Typescript的接口的实现和继承。阅读之前需要了解Typescript的接口，可以参考之前的文章 Typescript(二)：接口上一篇介绍了Typescript（以下简称ts…","fields":{"slug":"/typescript/inherit-and-type/"},"frontmatter":{"date":"June 17, 2019","title":"Typescript(三)：接口的实现和继承","description":"本篇为Typescript系列的第三篇，主要内容为Typescript的接口的实现和继承"}}},{"node":{"excerpt":"-本篇文章主要介绍Typescript接口，阅读之前需要了解Typescript的基本类型，可参考Typescript(一)：基本类型一门语言中的类型出了基本类型之外大部分都是自定义的类型，Typescript（以下简称ts）中提供两种定义类型的方式type…","fields":{"slug":"/typescript/interface/"},"frontmatter":{"date":"June 16, 2019","title":"Typescript(二)：接口","description":null}}},{"node":{"excerpt":".CodeMirror { height: auto; }\n.CodeMirror.cm-s-inner { background-image: inherit; background-size: inherit; background-attachment: inherit…","fields":{"slug":"/typescript/"},"frontmatter":{"date":"June 15, 2019","title":"Typescript(一)：基本类型","description":"本篇是Typescript系列的第一篇，介绍了什么是Typescript、为什么要用Typescript以及Typescript的基本类型"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}